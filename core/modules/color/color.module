<?php

/**
 * @file
 * Allows users to change the color scheme of themes.
 */

/**
 * Implements hook_form_FORM_ID_alter().
 */
function color_form_system_theme_settings_alter(&$form, &$form_state) {
  if (isset($form_state['build_info']['args'][0]) && ($theme = $form_state['build_info']['args'][0]) && color_get_info($theme) && function_exists('gd_info')) {
    $form['preview'] = array(
      '#type' => 'fieldset',
      '#title' => t('Preview'),
      '#weight' => -2,
      '#attributes' => array('id' => 'preview'),
      '#collapsible' => TRUE,
      'preview' => array(
        '#markup' => '<iframe src="' . url('<front>') . '"></iframe>',
      )
    );
    $form['color'] = array(
      '#type' => 'fieldset',
      '#title' => t('Color scheme'),
      '#weight' => -1,
      '#attributes' => array('id' => 'color_scheme_form'),
    );

    $info = color_get_info($theme);
    $default_scheme = config($theme . '.color.default');

    $schemes = array();
    $color_sets = array();
    foreach ($info->get('schemes') as $scheme_name) {
      $scheme_config = config($theme . '.color.' . $scheme_name);
      $schemes[$scheme_name] = $scheme_config->get('colors');
      $schemes[$scheme_name] += $default_scheme->get('colors');
      $color_sets[$scheme_name] = $scheme_config->get('title');
    }
    $schemes[''] = $info->get('palette');
    $color_sets[''] = t('Custom');

    // See if we're using a predefined scheme.
    // Note: we use the original theme when the default scheme is chosen.
    $current_scheme = $info->get('palette');
    foreach ($schemes as $key => $scheme) {
      if ($current_scheme == $scheme) {
        $scheme_name = $key;
        break;
      }
    }
    if (empty($scheme_name)) {
      if (empty($current_scheme)) {
        $scheme_name = 'default';
      }
      else {
        $scheme_name = '';
      }
    }

    // Add scheme selector.
    $form['color']['scheme'] = array(
      '#type' => 'select',
      '#title' => t('Color set'),
      '#options' => $color_sets,
      '#default_value' => $scheme_name,
      '#attached' => array(
        // Add custom JavaScript.
        'js' => array(
          $base . '/js/color.js',
          array(
            'data' => array(
              'color' => array(
                'reference' => $default_scheme->get('colors'),
                'schemes' => $schemes,
              ),
            ),
            'type' => 'setting',
          ),
        ),
      ),
    );
    $base = backdrop_get_path('module', 'color');

    backdrop_add_css($base . '/css/color.admin.css', array('type' => 'file'));

    // Add palette fields.
    $palette = color_get_palette($theme);
    $names = $info->get('fields');
    foreach ($palette as $name => $value) {
      if (isset($names[$name])) {
        $result = color_place_color_element($form, $name, $value, $names[$name]);
        if (!$result) {
          $form['color']['palette'][$name] = array(
            '#type' => 'color',
            '#title' => check_plain($names[$name]),
            '#value_callback' => 'color_palette_color_value',
            '#default_value' => $value,
            '#size' => 8,
          );
        }
      }
    }
    $form['theme'] = array('#type' => 'value', '#value' => $theme);

    $form['#validate'][] = 'color_scheme_form_validate';
    array_unshift($form['#submit'], 'color_scheme_form_submit');

    // Check for legacy Bartik colors.
    // @todo Remove in Backdrop 2.0.
    if ($theme === 'bartik') {
      module_load_include('inc', 'color', 'color.legacy');
      bartik_form_system_theme_settings_alter($form, $form_state);
    }
  }
}

function color_place_color_element(&$array, $name, $value, $human_name) {
  if (isset($array['color'][$name])) {
    $array['color'][$name] = array(
      '#type' => 'color',
      '#title' => check_plain($human_name),
      '#value_callback' => 'color_palette_color_value',
      '#default_value' => $value,
      '#size' => 8,
    );
    return TRUE;
  }
  else {
    foreach ($array as &$sub_array) {
      if (is_array($sub_array)) {
        $result = color_place_color_element($sub_array, $name, $value, $human_name);
        if ($result === TRUE) {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}

/**
 * Implements hook_css_alter().
 *
 * Replaces style sheets with color-altered style sheets.
 */
function color_css_alter(&$css) {
  global $theme_key;
  $themes = list_themes();

  // Override stylesheets.
  $config = config($theme_key . '.color');
  $color_paths = $config->get('modified');

  if (!empty($color_paths)) {
    foreach ($themes[$theme_key]->stylesheets['all'] as $old_path) {
      // Loop over the path array with recolored CSS files to find matching
      // paths which could replace the non-recolored paths.
      foreach ($color_paths as $color_path) {
        // Color module currently requires unique file names to be used,
        // which allows us to compare different file paths.
        if (backdrop_basename($old_path) == backdrop_basename($color_path)) {
          // Replace the path to the new css file.
          // This keeps the order of the stylesheets intact.
          $css[$old_path]['data'] = $color_path;
        }
      }
    }
  }
}

/**
 * Retrieves the Color module information for a particular theme.
 */
function color_get_info($theme) {
  $config = config($theme . '.color');

  if ($config->isNew()) {
    // Attempt to load the legacy color module settings.
    $path = backdrop_get_path('theme', $theme);
    $file = BACKDROP_ROOT . '/' . $path . '/color/color.inc';
    if ($path && file_exists($file)) {
      include $file;
      if (isset($info)) {
        $config->set('fields', $info['fields']);
        $config->set('schemes', array_keys($info['schemes']));
        $theme_setting = theme_get_setting('color', $theme);
        if (is_array($theme_setting)) {
          $config->set('palette', $theme_setting['palette']);
          $config->set('original', $theme_setting['stylesheets']);
          $config->set('modified', $theme_setting['files']);
        }
        else {
          $config->set('palette', array());
          $config->set('original', array());
          $config->set('modified', array());
        }
        $config->save();
        foreach ($info['schemes'] as $scheme_id => $scheme) {
          $scheme_config = config($theme . '.color.' . $scheme_id);
          $scheme_config->setData($scheme);
          $scheme_config->save();
        }
      }
    }
  }

  return $config;
}

/**
 * Retrieves the color palette for a particular theme.
 */
function color_get_palette($theme, $default = FALSE) {
  // Fetch and expand default palette.
  $default_scheme = config($theme . '.color.default');
  $palette = $default_scheme->get('colors');

  // Load config.
  $config = config($theme . '.color');
  if (!$default && ($theme_palette = $config->get('palette'))) {
    foreach ($theme_palette as $name => $color) {
      if (isset($palette[$name])) {
        $palette[$name] = $color;
      }
    }
  }
  return $palette;
}

/**
 * Determines if a hexadecimal CSS color string is valid.
 *
 * @param string $color
 *   The string to check.
 *
 * @return bool
 *   TRUE if the string is a valid hexadecimal CSS color string, or FALSE if it
 *   isn't.
 */
function color_valid_hexadecimal_string($color) {
  return preg_match('/^#([a-f0-9]{3}){1,2}$/iD', $color);
}

function color_get_values_from_form($form_state) {
  $default = color_get_palette($form_state['values']['theme'], TRUE);
  $palette = array();
  foreach ($default as $key => $color) {
    if (isset($form_state['values'][$key]) && color_valid_hexadecimal_string($form_state['values'][$key])) {
      $palette[$key] = $form_state['values'][$key];
    }
  }

  return $palette;
}

/**
 * Form validation handler for color_scheme_form().
 *
 * @see color_scheme_form_submit()
 */
function color_scheme_form_validate($form, &$form_state) {
  // Only accept hexadecimal CSS color strings to avoid XSS upon use.
  foreach (color_get_values_from_form($form_state) as $key => $color) {
    if (!color_valid_hexadecimal_string($color)) {
      form_set_error('palette][' . $key, t('You must enter a valid hexadecimal color value for %name.', array('%name' => $form['color']['palette'][$key]['#title'])));
    }
  }
}

/**
 * Form submission handler for color_scheme_form().
 *
 * @see color_scheme_form_validate()
 */
function color_scheme_form_submit($form, &$form_state) {
  // Get theme coloring info.
  $theme = $form_state['values']['theme'];
  $info = color_get_info($theme);

  // Resolve palette.
  $palette = color_get_values_from_form($form_state);
  if ($form_state['values']['scheme'] != '') {
    $scheme = config($theme . '.color' . $form_state['values']['scheme']);
    $scheme_palette = $scheme->get('colors');
    foreach ($palette as $key => $color) {
      if (isset($scheme_palette[$key])) {
        $palette[$key] = $scheme_palette[$key];
      }
    }
    $palette += color_get_palette($theme, TRUE);
  }

  // Delete old files.
  $files = $info->get('modified');
  if ($files) {
    foreach ($files as $file) {
      @backdrop_unlink($file);
    }
  }
  if (isset($file) && $file = dirname($file)) {
    @backdrop_rmdir($file);
  }

  // Don't render the default colorscheme, use the standard theme instead.
  if (implode(',', color_get_palette($theme, TRUE)) == implode(',', $palette)) {
    unset($form_state['values']['scheme']);
    unset($form_state['values']['palette']);
    $form_state['values']['color'] = NULL;
    return;
  }

  // Prepare target locations for generated files.
  $id = $theme . '-' . substr(hash('sha256', serialize($palette) . microtime()), 0, 8);
  $paths['color'] = 'public://color';
  $paths['target'] = $paths['color'] . '/' . $id;
  foreach ($paths as $path) {
    file_prepare_directory($path, FILE_CREATE_DIRECTORY);
  }
  $paths['target'] = $paths['target'] . '/';
  $paths['files'] = array();

  // Rewrite theme stylesheets.
  $files = array();
  $themes = list_themes();
  foreach ($themes[$theme]->stylesheets['all'] as $stylesheet) {
    // Build a temporary array with CSS files.
    if (file_exists($stylesheet)) {
      $files[] = $stylesheet;
    }
  }

  foreach ($files as $file) {
    // Aggregate @imports recursively for each configured top level CSS file
    // without optimization. Aggregation and optimization will be
    // handled by backdrop_build_css_cache() only.
    $style = backdrop_load_stylesheet($file, FALSE);

    // Return the path to where this CSS file originated from, stripping
    // off the name of the file at the end of the path.
    $base = base_path() . dirname($file) . '/';
    _backdrop_build_css_path(NULL, $base);

    // Prefix all paths within this CSS file, ignoring absolute paths.
    $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_backdrop_build_css_path', $style);

    // Rewrite stylesheet with new colors.
    $style = _color_rewrite_stylesheet($theme, $palette, $style);
    $base_file = backdrop_basename($file);
    _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);
  }

  // Save all the values into form state for saving to config.
  $config = config($theme . '.color');
  $config->set('palette', $palette);
  $config->set('original', $files);
  $config->set('modified', $paths['files']);
  $config->save();

  // Remove color field elements.
  foreach ($palette as $key => $value) {
    unset($form_state['values'][$key]);
  }
  unset($form_state['values']['scheme']);
  unset($form_state['values']['palette']);
  unset($form_state['values']['color']);
}

/**
 * Rewrites the stylesheet to match the colors in the palette.
 */
function _color_rewrite_stylesheet($theme, $palette, $style) {
  $themes = list_themes();
  // Prepare color conversion table.
  $conversion = $palette;
  foreach ($conversion as $k => $v) {
    $conversion[$k] = backdrop_strtolower($v);
  }
  $default = color_get_palette($theme, TRUE);

  // Find all colors in the stylesheet and the chunks in between.
  $style = preg_split('/(#[0-9a-f]{6}|#[0-9a-f]{3})/i', $style, -1, PREG_SPLIT_DELIM_CAPTURE);
  $is_color = FALSE;
  $output = '';
  $base = 'base';

  // Iterate over all the parts.
  foreach ($style as $chunk) {
    if ($is_color) {
      $chunk = backdrop_strtolower($chunk);
      // Check if this is one of the colors in the default palette.
      if ($key = array_search($chunk, $default)) {
        $chunk = $conversion[$key];
      }
    }
    else {
      // 'a' declarations. Use link.
      if (preg_match('@[^a-z0-9_-](a)[^a-z0-9_-][^/{]*{[^{]+$@i', $chunk)) {
        $base = 'link';
      }
      // 'color:' styles. Use text.
      elseif (preg_match('/(?<!-)color[^{:]*:[^{#]*$/i', $chunk)) {
        $base = 'text';
      }
      // Reset back to base.
      else {
        $base = 'base';
      }
    }
    $output .= $chunk;
    $is_color = !$is_color;
  }

 return $output;
}

/**
 * Saves the rewritten stylesheet to disk.
 */
function _color_save_stylesheet($file, $style, &$paths) {
  $filepath = file_unmanaged_save_data($style, $file, FILE_EXISTS_REPLACE);
  $paths['files'][] = $filepath;

  // Set standard file permissions for webserver-generated files.
  backdrop_chmod($file);
}
